[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Portfolio",
    "section": "",
    "text": "See more posts in Archive…\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nCase study - Average temperature in Europe from 2011 to 2022\n\n\n5 min\n\n\n\nR\n\n\nGIS\n\n\nVisualization\n\n\nCase study\n\n\n\n\nNov 22, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnimated plots in R with gganimate package\n\n\n7 min\n\n\n\nR\n\n\nVisualization\n\n\n\n\nNov 19, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinear regression diagnostics in R with lindia package\n\n\n13 min\n\n\n\nR\n\n\nRegression\n\n\n\n\nNov 17, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGIS with R - Coordinate Reference Systems in R\n\n\n6 min\n\n\n\nR\n\n\nGIS\n\n\n\n\nNov 9, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGIS with R - Raster data\n\n\n3 min\n\n\n\nR\n\n\nGIS\n\n\n\n\nNov 8, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGIS with R - Vector data\n\n\n6 min\n\n\n\nR\n\n\nGIS\n\n\n\n\nNov 6, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData cleansing with Janitor R package\n\n\n3 min\n\n\n\nR\n\n\nData cleansing\n\n\n\n\nNov 3, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nColorblind palettes in R with viridisLite package\n\n\n2 min\n\n\n\nR\n\n\nVisualization\n\n\nAccessibility\n\n\n\n\nOct 30, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDependency management with renv R package\n\n\n3 min\n\n\n\nR\n\n\nDependency management\n\n\n\n\nOct 29, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCase study - Cyclistic\n\n\n19 min\n\n\n\nR\n\n\nCase study\n\n\n\n\nOct 19, 2022\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "archive.html",
    "href": "archive.html",
    "title": "Archive",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nReading Time\n\n\nCategories\n\n\n\n\n\n\nNov 22, 2022\n\n\nCase study - Average temperature in Europe from 2011 to 2022\n\n\n5 min\n\n\nR,GIS,Visualization,Case study\n\n\n\n\nNov 19, 2022\n\n\nAnimated plots in R with gganimate package\n\n\n7 min\n\n\nR,Visualization\n\n\n\n\nNov 17, 2022\n\n\nLinear regression diagnostics in R with lindia package\n\n\n13 min\n\n\nR,Regression\n\n\n\n\nNov 9, 2022\n\n\nGIS with R - Coordinate Reference Systems in R\n\n\n6 min\n\n\nR,GIS\n\n\n\n\nNov 8, 2022\n\n\nGIS with R - Raster data\n\n\n3 min\n\n\nR,GIS\n\n\n\n\nNov 6, 2022\n\n\nGIS with R - Vector data\n\n\n6 min\n\n\nR,GIS\n\n\n\n\nNov 3, 2022\n\n\nData cleansing with Janitor R package\n\n\n3 min\n\n\nR,Data cleansing\n\n\n\n\nOct 30, 2022\n\n\nColorblind palettes in R with viridisLite package\n\n\n2 min\n\n\nR,Visualization,Accessibility\n\n\n\n\nOct 29, 2022\n\n\nDependency management with renv R package\n\n\n3 min\n\n\nR,Dependency management\n\n\n\n\nOct 19, 2022\n\n\nCase study - Cyclistic\n\n\n19 min\n\n\nR,Case study\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/gganimate/index.html",
    "href": "posts/gganimate/index.html",
    "title": "Animated plots in R with gganimate package",
    "section": "",
    "text": "If you ever thought static plots to be a bit bland or not enough powerful to represent all the nuances of your data, then gganimate package is what you need to further improve your visualizations. gganimate extends the grammar of graphics as implemented by ggplot2 to include the description of animation. It does this by providing a range of new grammar classes that can be added to the plot object in order to customise how it should change with time.\n\ntransition_*() defines how the data should be spread out and how it relates to itself across time.\nview_*() defines how the positional scales should change along the animation.\nshadow_*() defines how data from other points in time should be presented in the given point in time.\nenter_*()/exit_*() defines how new data should appear and how old data should disappear during the course of the animation.\nease_aes() defines how different aesthetics should be eased during transitions.\n\n\n\nInstall gganimate\n\nYou can install gganimate from CRAN repository with:\n\ninstall.packages(\"gganimate\")\n\nOr the the developer version from GitHub with:\n\ndevtools::install_github('thomasp85/gganimate')\n\n\n\n\nPackages\n\nWe start by loading the needed packages.\n\nlibrary(reshape2)\nlibrary(ggplot2)\nlibrary(gganimate)\nlibrary(gifski)\n\n\n\n\n\n\n\nNote:\n\n\n\nBy default, gganimate writes each animation frame to separate image files. and stops there. You can produce gif outputs by installing gifski package, or video outputs with av package. If installed, gganimate will automatically detect the rendering backend, but you can also manually choose the rendering method by setting the renderer parameter of gganimate::animate() to the desired value. See ?gganimate::animate() for more details.\n\n\nBefore proceding, I’ll explain some key concepts of animated data visualization.\n\n\n\nTweening\n\nAnimation has always been about the illusion of movement. Tweening is a major part of making that illusion look real. Tweening in animation is a short for inbetweening, and it’s the process of generating images that go between keyframes. Keyframes are the images at the beginning and end of a smooth transition.\nIn the context of data visualization, tweening is the process of splitting data into subsets based on a variable in the data, and calculating intermediary data states that ensures a smooth transition between the states. gganimate provides a wide range of different transitions, for different datatypes, defined by transition_*() functions. We’ll see some examples later.\n\n\n\nEasing\n\nIn the context of animation, easing lends a natural, organic movement to motion. A linear animation (one built without easing) will move mechanically without slowing down or speeding up. As this kind of consistency in speed doesn’t occur in nature, we perceive the movement as unnatural. Objects in real life don’t start moving and maintaining the same speed throughout. They start slowly, pick up speed and slow down as they come to a halt. That’s why gganimate supports the easing of animations with ease_aes() function.\nThere are plenty of different easing methods, defined by an easing function and by an easing modifier. For a list of available easing functions, see ?tweenr::display_ease (tweenr package is a dependency of gganimate). Below I explain the 3 different modifiers.\n\nIn: applies the easing function as-is.\nOut: applies the easing function in reverse.\nIn-Out: the first half of the transition is applied as-is, while the last half is applied in reverse.\n\nFor a visual representation of all the combinations of easing functions and modifiers, see easing.net webpage. We’ll see some examples later.\n\n\n\nLabeling\n\nIt can be quite hard to understand an animation without any indication as to what each point relates to. gganimate solves this by providing a set of variables for each frame, which can be inserted into plot labels using glue syntax.\n\n\n\nExample 1: mtcars dataset\n\nNow we’re ready for some actual animations. We start with the R prebuilt mtcars dataset.\n\ndatasets::mtcars\n\n\n\n  \n\n\n\nBelow a standard static plot of ‘mpg’ (miles per US gallon) variable by ‘cyl’ (number of cylinders) variable, built with ggplot2 . First we apply a custom theme.\n\n\nCustom theme\nggplot2::theme_update(\n  axis.text = element_text(size = 11),\n  legend.background = element_blank(),\n  panel.background = element_rect(fill = \"grey85\"),\n  panel.border = element_rect(colour = \"black\", fill = NA),\n  panel.grid = element_line(colour = \"whitesmoke\"),\n  panel.grid.minor.y = element_blank(),\n  panel.grid.minor.x = element_blank(),\n  plot.title = element_text(hjust = 0.5),\n  plot.subtitle = element_text(face = \"italic\", hjust = 0.5),\n  strip.background = element_rect(colour = \"black\", fill = \"grey85\"),\n  strip.text = element_text(size = 10, face = \"bold\"),\n  title = element_text(size = 12, face = \"bold\")\n)\n\n\n\nh <- ggplot(mtcars, aes(y = as.factor(cyl), x = mpg)) +\n  geom_boxplot(aes(fill = as.factor(cyl)), show.legend = F) +\n  scale_x_continuous(limits = c(10, 35), breaks = seq(10,35,2.5)) +\n  labs(title = \"Miles per gallon (mpg) by num. of cylinders (cyl)\", y = \"cyl\")\nh\n\n\n\n\nNow let’s say we want to see how the transmission type (‘am’ variable) influences the miles per gallon for each amount of cylinders. We can add an animation based on ‘am’ variable, which is categorical/binary (0 for automatic transmission, and 1 for manual transmission) with gganimate::transition_states() . This transition splits your data into multiple states based on the levels in a given column. We add the transition by simply adding a new layer to our plot, like we do in base ggplot2 .\n\nh_anim <- h +\n  transition_states(states = as.factor(am), transition_length = 2, state_length = 1) +\n  ease_aes(\"cubic-in-out\") +\n  labs(subtitle = \"Transmission, am = {closest_state}\")\nh_anim\n\n\n\n\nAs you can see, the manual transmission (‘am’ = 1) is associated with a lower fuel consumption, on average, for each amount of cylinders.\nWith transition_length parameter we set the relative length of the transition between different states, while the relative length of the pause at each state is defined by state_length parameter. For a better animation, the easing modifier in ease_aes() was set to “in-out” for a slower start and end of each transition. Finally, a subtitle with glue syntax was added, so that the label changes whenever there’s a state transition. For a list of the available label variables for transition_states() function, see its documentation with ?gganimate::transition_states .\n\n\n\n\n\n\nCaution:\n\n\n\nThe glue syntax is automatically detected only when used inside ggplot2 labels functions (for example ggtitle() , labs() , etc.\n\n\nWe can also change the rendering parameters with animate() function. For example, below we set the number of frames to 200 (default = 100) for a smoother animation.\n\nh_anim |> animate(nframes = 200)\n\n\n\n\n\n\n\nExample 2: iris dataset\n\nNow we’ll build an additional visualization on iris R prebuilt dataset.\n\ndatasets::iris\n\n\n\n  \n\n\n\nLet’s say we want to see what iris species have the longest and largest petals. We can draw a simple scatterplot to find out the “biggest” species.\n\ns <- ggplot(iris, aes(x = Petal.Width, y = Petal.Length)) +\n  geom_point(aes(colour = Species)) +\n  labs(title = \"Petal.length vs Petal.Width\")\ns\n\n\n\n\nNow, this particular plot is clear and straightforward, and already fine as it is. Each species takes a specific area in the plot, and there’s almost no overlapping of data points. However, overlapping is a very common problem of scatter plots, especially when there are many data points, and creating an animation with different states can solve it, so let’s animate our iris plot.\n\ns_anim <- s +\n  transition_states(Species, transition_length = 2) +\n  ease_aes(\"quadratic-in-out\") +\n  enter_fade() +\n  exit_shrink() +\n  labs(subtitle = \"Species = {closest_state}\") +\n  theme(legend.position = \"none\")\ns_anim\n\n\n\n\nThis time, custom enter and exit behaviours were set. In iris dataset, each row represents a different individual, there aren’t multiple observations of the same individual, so we don’t want the data points to move across the plot (default behaviour). If that was the case, it would appear as if data in a single measurement changes gradually as the flower being measured on somehow morphs between three different iris species, which obviously doesn’t make sense. To avoid this problem, an exit_shrink() call was added, so that the data points shrink in size and disappear when there’s a transition between states, rather than moving. Here, enter_fade() is just an aesthetic improvement (the data points start at max transparency and end up with the transparency level you set when building the plot; no transparency in this case).\n\n\n\nExample 3: USPersonalExpenditure dataset\n\nAs final example, we’ll build an animation on a custom long version of USPersonalExpenditure R prebuilt dataset.\n\nlong_USPE <- function() {\n  df <- datasets::USPersonalExpenditure |> as.data.frame()\n  df$category <- rownames(df)\n  df <- reshape2::melt(df, \"category\")\n  df$variable <- ordered(df$variable)\n  names(df) <- c(\"category\", \"year\", \"expenditure\")\n  return(df)\n}\nlong_USPE()\n\n\n\n  \n\n\n\nFirst, we build a static visualization.\n\nl <- ggplot(long_USPE(), aes(x = year, y = expenditure, group = category, colour = category)) +\n  geom_line() +\n  geom_point() +\n  labs(title = \"US personal expenditures\", y = \"Expenditure (billions $)\", x = \"Year\")\nl\n\n\n\n\nThe line plot here is already fine, and is a good representation of the increasing trends of personal expenditures from 1940 to 1960, but we can make it more visually appealing by adding a transition_reveal() call, which allows the data to gradually appear, along a given time dimension.\n\nl_anim <- l +\n  geom_text(aes(label = expenditure |> round(2) |> format(nsmall = 2)), fontface = \"bold\", parse = T, \n            check_overlap = T, nudge_x = .2, nudge_y = 1) +\n  transition_reveal(as.numeric(year)) +\n  ease_aes(\"quadratic-in-out\") +\n  theme(legend.position = c(0.15,0.8), legend.title = element_blank())\nl_anim"
  },
  {
    "objectID": "posts/avgtemp/index.html",
    "href": "posts/avgtemp/index.html",
    "title": "Case study - Average temperature in Europe from 2011 to 2022",
    "section": "",
    "text": "In this brief case study I’ll analyze average temperatures in Europe from 2011 to 2022 (up to June 2022) and build an animated raster plot of temperatures with terra , ggplot2 and gganimate packages.\n\n\nPackages\n\nWe start by loading the needed packages\n\n\nlibrary(data.table) # fast data manipulation for big datasets\nlibrary(reshape2)\nlibrary(terra)\nlibrary(xts)      # packages for time \nlibrary(tsbox)    # series objects\nlibrary(ggplot2)\nlibrary(gganimate)\nlibrary(RColorBrewer)\n\n\n\nE-OBS dataset\n\nOur data source is a subset of the open E-OBS dataset provided by Copernicus Climate Change Service (C3S). To manually access the data, open the E-OBS link I just provided, scroll down until you see ‘Access to smaller chunks’ section, and click on the corresponding link. Then, find the 2011-2022 subset of the 0.25 degree resolution dataset and click on ‘TG’ (which stands for daily mean temperature). Here I choose the lower resolution version since it’s more lightweight. Do the same for the 0.1 degree resolution if you want more precise data.\nHere I’ll directly scrape the dataset from Copernicus website.\n\nUrl <- \"https://knmi-ecad-assets-prd.s3.amazonaws.com/ensembles/data/Grid_0.25deg_reg_ensemble/tg_ens_mean_0.25deg_reg_2011-2022_v26.0e.nc\"\ntemp <- tempfile(fileext = \".nc\")\noptions(timeout = 5000); download.file(url = Url, temp, mode = \"wb\"); options(timeout = 60)\n\nrt <- terra::rast(temp)\nrt\n\nclass       : SpatRaster \ndimensions  : 201, 464, 4199  (nrow, ncol, nlyr)\nresolution  : 0.25, 0.25  (x, y)\nextent      : -40.5, 75.5, 25.25, 75.5  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 \nsource      : file258c47a32c99.nc \nvarname     : tg (mean temperature) \nnames       :    tg_1,    tg_2,    tg_3,    tg_4,    tg_5,    tg_6, ... \nunit        : Celsius, Celsius, Celsius, Celsius, Celsius, Celsius, ... \ntime (days) : 2011-01-01 to 2022-06-30 \n\n\nThese are daily data ranging from 2011-01-01 to 2022-06-30.\n\n\n\nExtract monthly subset\n\nSince the object contains more than 80 millions cells (201 rows, 464 columns and 4199 layers), I’ll extract a subset (a single day for each month) in order to improve the rendering time.\nFirst, in order to plot the data, the SpatRaster object must be converted into a data.frame-like format. Here I’ll convert it to data.table format for better performance.\n\ndt <- as.data.table(rt, xy = T)\n\ndaily_range <- seq.Date(from = as.Date(\"2011-01-01\"), to = as.Date(\"2022-06-30\"), by = \"day\") |>\n  as.character()\nnames(dt) <- c(\"x\", \"y\", daily_range)\n\ndim(dt)\n\n[1] 19902  4201\n\n\nThe result is a data.table with 19.902 rows and 4201 columns, the first two being the x and y coordinates of raster grid cells, and the other ones being the grid cells values for each day. Then, all column names, except the first two, where changed to match their corresponding dates.\nNow, since the wide format isn’t ggplot2-friendly, the data must be converted to long format, with reshape2::melt() function.\n\ndt_long <- melt(dt, id.vars = c(\"x\",\"y\")) |> as.data.table() |> setkeyv(c(\"x\", \"y\"))\nnames(dt_long) <- c(\"x\", \"y\", \"date\", \"value\")\nstr(dt_long)\n\nClasses 'data.table' and 'data.frame':  83568498 obs. of  4 variables:\n $ x    : num  -24.9 -24.9 -24.9 -24.9 -24.9 ...\n $ y    : num  69.4 69.4 69.4 69.4 69.4 ...\n $ date : Factor w/ 4199 levels \"2011-01-01\",\"2011-01-02\",..: 1 2 3 4 5 6 7 8 9 10 ...\n $ value: num  NA NA NA NA NA NA NA NA NA NA ...\n - attr(*, \".internal.selfref\")=<externalptr> \n - attr(*, \"sorted\")= chr [1:2] \"x\" \"y\"\n\n\nFinally, we can extract the monthly subset.\n\nmonthly_range <- seq.Date(from = as.Date(\"2011-01-01\"), to = as.Date(\"2022-06-30\"), by = \"month\") |> \n  as.character()\n\ndt_monthly <- dt_long[date %in% monthly_range]\ndt_monthly$date <- as.Date(dt_monthly$date)\n\nstr(dt_monthly)\n\nClasses 'data.table' and 'data.frame':  2746476 obs. of  4 variables:\n $ x    : num  -24.9 -24.9 -24.9 -24.9 -24.9 ...\n $ y    : num  69.4 69.4 69.4 69.4 69.4 ...\n $ date : Date, format: \"2011-01-01\" \"2011-02-01\" ...\n $ value: num  NA NA NA NA NA NA NA NA NA NA ...\n - attr(*, \".internal.selfref\")=<externalptr> \n - attr(*, \"sorted\")= chr [1:2] \"x\" \"y\"\n\n\nThis final subset has 2.746.476 rows, way less than the 83.568.498 rows in dt_long. This should provide a good performance improvement.\n\n\n\nA quick time series decomposition\n\nBefore building the animated plot, let’s do a quick time series decomposition to see if the trend component of our daily data is increasing. First, we summarize our daily means (i.e. we compute means of raster pixels values for each day; means of avg. temperatures in whole Europe).\n\nsumm <- dt_long[, .(mean = mean(value, na.rm = T)), by = date]\nsumm$date <- as.Date(summ$date)\nsumm\n\n\n\n  \n\n\n\nThen we convert ‘summ’ into a time series object, that can be used with the decomposition function stl() .\n\nts <- xts::xts(summ$mean, order.by = summ$date) |> tsbox::ts_ts()\nstr(ts)\n\n Time-Series [1:4199] from 2011 to 2022: -2.17 -1.96 -3.62 -5.27 -5.17 ...\n\n\nFinally we plot the the time series decomposition.\n\nstl(ts, s.window = 365) |> \n  plot(main = \"Time series decomposition of avg. daily temp. in Europe\\nFrom 2011-01-01 to 2022-30-06\")\n\n\n\n\nThere’s a clear increasing trend from 8°C ca. up to more than 9°C, from 2011 to start of 2020, that later reverts back to 2011-2012 values.\n\n\n\n\n\n\nChoose a color palette\n\nBefore building the animated plot, we should choose a good color palette. Since we’re dealing with temperature data in degrees Celsius (which have a 0 value), a diverging palette is ideal. RColorBrewer package offers many diverging colorblind-friendly palettes. Show the available palettes with RColorBrewer::display.brewer.all() function.\n\ndisplay.brewer.all(type = \"div\", colorblindFriendly = T)\n\n\n\n\nThe first palette (RdYlBu) is a perfect choice for temperature data, so we’ll stick with it in the following visualizations.\n\n\n\nStatic example\n\nBefore rendering the actual animation, let’s try to plot a static chart for a specific date (for example 2011-01-01). First, we set a custom ggplot2 dark theme, for better contrast with RColorBrewer palette.\n\n\nCustom theme\ntheme_update(\n  axis.text = element_text(size = 9, colour = \"whitesmoke\"),\n  axis.ticks = element_line(colour = \"whitesmoke\"),\n  legend.background = element_blank(),\n  panel.background = element_rect(fill = \"gray15\"),\n  panel.border = element_rect(colour = \"whitesmoke\", fill = NA),\n  panel.grid.major = element_line(colour = \"grey10\"),\n  panel.grid.minor = element_blank(),\n  plot.background = element_rect(fill = \"gray10\"),\n  plot.title = element_text(hjust = 0.5),\n  plot.subtitle = element_text(face = \"italic\", hjust = 0.5),\n  strip.background = element_rect(colour = \"gray10\", fill = \"grey10\"),\n  strip.text = element_text(size = 9, face = \"bold\"),\n  title = element_text(size = 10, face = \"bold\"),\n  text = element_text(colour = \"whitesmoke\")\n)\n\n\nThen we use ggplot2::geom_raster() to plot the data.\n\nstatic <- ggplot(dt_monthly[date == \"2011-01-01\"], aes(x, y, fill = value)) +\n  geom_raster(interpolate = T) +\n  coord_sf(crs = 4326) +\n  scale_fill_gradientn( colours = brewer.pal(11, \"RdYlBu\") |> rev() ) +\n  labs(x = \"lon\", y = \"lat\", title = \"Avg. temperature\", subtitle = \"Date: 2011-01-01\", fill = \"Temp. (C°)\")\nstatic\n\n\n\n\nUnfortunately there are some missing cells for Turkey and North Africa; anyway we got a nice static map of average temperatures in 2011-01-01.\n\n\n\nAnimated plot\n\nFinally let’s see how temperatures change over time with an animated plot. See Animated plots in R with gganimate package for a quick introduction to gganimate package.\n\nanim <- ggplot(dt_monthly, aes(x, y, fill = value)) +\n  geom_raster(interpolate = T) +\n  scale_fill_gradientn( colours = brewer.pal(11, \"RdYlBu\") |> rev() ) +\n  transition_states(as.character(date)) +\n  ease_aes(\"quadratic-in-out\") +\n  labs(x = \"lon\", y = \"lat\", title = \"Avg. temperature\", subtitle = \"Date: {closest_state}\")\n\nanimate(anim, nframes = length(monthly_range)*4+50, end_pause = 50, duration = 90)\n\n\n\n\n\n\nUnfortunately, due to the limitations of my personal hardware I can’t render smoother and more detailed animations. Anyway this is still a nice showcase of gganimate and spatial packages working together in R.\n\n\n\nAcknowledgments\n\n“I acknowledge the E-OBS dataset from the EU-FP6 project UERRA (https://www.uerra.eu) and the Copernicus Climate Change Service, and the data providers in the ECA&D project (https://www.ecad.eu)”\nCornes, R., G. van der Schrier, E.J.M. van den Besselaar, and P.D. Jones. 2018: An Ensemble Version of the E-OBS Temperature and Precipitation Datasets, J. Geophys. Res. Atmos., 123. doi:10.1029/2017JD028200”"
  }
]