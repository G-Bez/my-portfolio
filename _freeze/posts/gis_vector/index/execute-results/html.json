{
  "hash": "bb15385a3719482b1c67bc3d96b08528",
  "result": {
    "markdown": "---\ntitle: \"GIS with R - Vector data\"\ndate: \"2022-11-06\"\ncategories: [R, GIS]\nimage: gis_thumbnail.jpg\nformat:\n  html:\n    code-tools: true\n    df-print: paged\n    fontsize: 0.9em\n    include-in-header: navbar.html\n    css: theme.css\n    toc: true\ncomments: \n    utterances: \n      repo:  G-Bez/my-portfolio \n      theme: photon-dark\ntitle-block-banner: false\neditor: visual\n---\n\n::: {.cell}\n<style type=\"text/css\">\n.justify {\n  text-align: justify !important\n}\n</style>\n:::\n\n\n::: justify\nGIS is an acronym that is typically used to refer to a geographic information system. We can define a GIS as any software able to read, store, analyze, combine and manipulate spatially referenced data. The main conceptual feature of a geographic information system is that it can layer data based on their co-location such that seemingly unrelated data can be combined based on the fact they are located in the same area (see @fig-layer).\n\n![Conceptual diagram of a geographic information system.](image.jpg){#fig-layer alt=\"Conceptual diagram of a geographic information system.\" fig-align=\"center\"}\n\nTipically GIS represent spatial data in two different formats (or combinations of both):\n\n-   **Vector data**: represent spatial features with points, lines, polygons and other geometries. These have discrete, well-defined borders, meaning that vector datasets usually have a high level of precision. More in detail, the geographic vector data model is based on points located within a coordinate reference system (CRS). Points can represent self-standing features (for example the location of a bus stop) or they can be linked together to form more complex geometries such as lines and polygons\n-   **Raster data**: represent spatial features with continuous grids of pixels. Raster datasets are the basis of background images used in web-mapping and have been a vital source of geographic data since the origins of aerial photography and satellite-based remote sensing devices. See [GIS with R - Raster data](https://g-bez.github.io/my-portfolio/posts/gis_raster/) for examples about raster data in R.\n\nFor all intents and purposes, R can be used as a GIS. Following I provide some examples on how to deal with vector data in R.\n:::\n\n## Packages\n\n::: justify\nWe start by loading the needed packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(patchwork)\n```\n:::\n\n\nThe `sf` package can be used to represent different geometry types in R. In addition to points, lines and polygons, there are 14 additional types of geometry that can be represented in `sf` which for now we ignore, but are detailed in the `sf` [vignette](https://r-spatial.github.io/sf/articles/sf1.html). `ggspatial` package is a spatial data framework for `ggplot2` .\n:::\n\n## Points\n\n::: justify\nPoints are the simplest spatial geometry, and are defined by a single XY coordinate. We can use `sf::st_point()` function to define a point.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npt <- sf::st_point(c(10,20))\nattributes(pt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$class\n[1] \"XY\"    \"POINT\" \"sfg\"  \n```\n:::\n:::\n\n\n`attributes()` function shows the different components of the object. As we can see, we got an sfg object of geometry type POINT as output. sfg is shorthand for Simple Feature Geometry objects, aka objects that only store XY coordinates and don't have any information on the geographic coordinate system, datum or projection those coordinates are in, nor do they have any other attribute data associated with that point.\n\nIf we want to create an object with more than one point we need to aggregate points objects into a **Simple Feature geometry Column (sfc)** object, with `sf:st_sfc()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### list of random points with coords between 40 and 75\nn <- 10\nvec <- c(55:75)\nls <- vector(\"list\", n)\nls <- lapply(1:n, sample, x = vec, size = 2) |> lapply(st_point)\nnames(ls) <- paste(\"point\", seq(1:n), sep = \"\")\n\n#### sfc object\npts_sfc <- sf::st_sfc(ls)\nattributes(pts_sfc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n [1] \"point1\"  \"point2\"  \"point3\"  \"point4\"  \"point5\"  \"point6\"  \"point7\" \n [8] \"point8\"  \"point9\"  \"point10\"\n\n$class\n[1] \"sfc_POINT\" \"sfc\"      \n\n$precision\n[1] 0\n\n$bbox\nxmin ymin xmax ymax \n  55   56   71   74 \n\n$crs\nCoordinate Reference System: NA\n\n$n_empty\n[1] 0\n```\n:::\n:::\n\n\nAs you can see, sfc objects store additional attributes, like the **bounding box** (smallest rectangle that would encompass all elements in the data), decimal precision of coordinates, and CRS which is blank for now. Each reference system is defined by a corresponding `EPSG` code; see [EPSG website](https://epsg.org/home.html), [Spatial Reference website](https://spatialreference.org/ref/epsg/) and [GIS with R - CRSs in R](https://g-bez.github.io/my-portfolio/posts/gis_crs/) post for more details. To add a CRS attribute to our sfc object, add a `crs` parameter to `sf::st_sfc()` function. For example, let's say that we built the data based on longitude and latitude coordinates using a very commonly used geographic coordinate system called [WGS84](https://support.virtual-surveyor.com/en/support/solutions/articles/1000261351-what-is-wgs84-), which has an EPSG code of 4326.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npts_sfc <- sf::st_sfc(ls, crs = 4326)\nattributes(pts_sfc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n [1] \"point1\"  \"point2\"  \"point3\"  \"point4\"  \"point5\"  \"point6\"  \"point7\" \n [8] \"point8\"  \"point9\"  \"point10\"\n\n$class\n[1] \"sfc_POINT\" \"sfc\"      \n\n$precision\n[1] 0\n\n$bbox\nxmin ymin xmax ymax \n  55   56   71   74 \n\n$crs\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n\n$n_empty\n[1] 0\n```\n:::\n:::\n\n\nAs you can see, we succesfully added a CRS attribute to our set of points. However, sfc objects don't support custom attributes (not intended as R object attributes, but rather as characteristics associated with any given feature in a vector dataset).\n\nFor example, let's say the points I just created represent the location of fast food restaurants, and for each restaurant we have informations about the corresponding brand. Since sfc objects can't store additional attributes, we need to create a **Simple Feature (sf)** object with `sf::st_sf()` function which can integrate both the location and the attribute data. First we create the attribute dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Casual brand attributes from list of brands \nbrands <- c(\"McDonald's\", \"Burger King\", \"America Graffiti\", \"KFC\", \"Pizza Hut\")\natt <- data.frame(brand = sample(brands, n, replace = T))\natt\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"brand\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"KFC\"},{\"1\":\"Pizza Hut\"},{\"1\":\"Pizza Hut\"},{\"1\":\"Pizza Hut\"},{\"1\":\"America Graffiti\"},{\"1\":\"America Graffiti\"},{\"1\":\"Pizza Hut\"},{\"1\":\"KFC\"},{\"1\":\"Burger King\"},{\"1\":\"America Graffiti\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nNow we can associate the attributes with location data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npts_sf <- sf::st_sf(att, geometry = pts_sfc)\npts_sf\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"brand\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"geometry\"],\"name\":[2],\"type\":[\"sf_POINT\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"KFC\",\"2\":\"<sf_POINT>\",\"_rn_\":\"1\"},{\"1\":\"Pizza Hut\",\"2\":\"<sf_POINT>\",\"_rn_\":\"2\"},{\"1\":\"Pizza Hut\",\"2\":\"<sf_POINT>\",\"_rn_\":\"3\"},{\"1\":\"Pizza Hut\",\"2\":\"<sf_POINT>\",\"_rn_\":\"4\"},{\"1\":\"America Graffiti\",\"2\":\"<sf_POINT>\",\"_rn_\":\"5\"},{\"1\":\"America Graffiti\",\"2\":\"<sf_POINT>\",\"_rn_\":\"6\"},{\"1\":\"Pizza Hut\",\"2\":\"<sf_POINT>\",\"_rn_\":\"7\"},{\"1\":\"KFC\",\"2\":\"<sf_POINT>\",\"_rn_\":\"8\"},{\"1\":\"Burger King\",\"2\":\"<sf_POINT>\",\"_rn_\":\"9\"},{\"1\":\"America Graffiti\",\"2\":\"<sf_POINT>\",\"_rn_\":\"10\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nFinally we can plot our data with `ggplot2` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ggplot2::ggplot(pts_sf, aes(geometry = geometry, colour = brand)) +\n  geom_sf() +\n  labs(x = \"lon\", y = \"lat\")\np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=100% height=250%}\n:::\n:::\n\n:::\n\n## Lines\n\n::: {#.justify}\nWe can repeat the same process as above, but for line objects (`LINESTRING` geometry). We can create a single line with `sf::st_linestring()` function, which takes as input a matrix with at least two XY coordinates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nline <- matrix(c(10,12,20,15,22,21,10,6,5,16), ncol = 2, byrow = T) |> \n  sf::st_linestring()\nline\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLINESTRING (10 12, 20 15, 22 21, 10 6, 5 16)\n```\n:::\n:::\n\n\nBelow an sfc object with multiple lines and associated CRS code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl1 <- matrix(c(10,10,10,12,14,16,15,10), ncol = 2, byrow = T) |> sf::st_linestring()\nl2 <- matrix(c(14,16,10,19), ncol = 2, byrow = T) |> sf::st_linestring()\nl3 <- matrix(c(10,12,5,13), ncol = 2, byrow = T) |> sf::st_linestring()\n\nline_sfc <- sf::st_sfc(l1,l2,l3, crs = 4326)\nline_sfc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGeometry set for 3 features \nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 5 ymin: 10 xmax: 15 ymax: 19\nGeodetic CRS:  WGS 84\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLINESTRING (10 10, 10 12, 14 16, 15 10)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLINESTRING (14 16, 10 19)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLINESTRING (10 12, 5 13)\n```\n:::\n:::\n\n\nLet's say these lines represent roads. We now create a dedicated attribute dataframe, with road names and speed limits, and attach them to lines data with `sf::st_sf()` .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl_att <- data.frame(road_name = c(\"Viale Garibaldi\", \"Via Voltaire\", \"Viale Pasolini\"), \n                    speed_limit = c(75, 50, 30))\nline_sf <- sf::st_sf(l_att, line_sfc)\nline_sf\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"road_name\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"speed_limit\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"line_sfc\"],\"name\":[3],\"type\":[\"s_LINEST\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Viale Garibaldi\",\"2\":\"75\",\"3\":\"<s_LINEST>\",\"_rn_\":\"1\"},{\"1\":\"Via Voltaire\",\"2\":\"50\",\"3\":\"<s_LINEST>\",\"_rn_\":\"2\"},{\"1\":\"Viale Pasolini\",\"2\":\"30\",\"3\":\"<s_LINEST>\",\"_rn_\":\"3\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nNow let's plot the lines.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ggplot2::ggplot(line_sf, aes(geometry = line_sfc, colour = road_name)) +\n  geom_sf() +\n  labs(title = \"road_name\", x = \"lon\", y = \"lat\")\n\np2 <- ggplot2::ggplot(line_sf, aes(geometry = line_sfc, colour = speed_limit)) +\n  geom_sf() +\n  labs(title = \"speed_limit\", x = \"lon\", y = \"lat\")\n\np1 / p2\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=100% height=250%}\n:::\n:::\n\n:::\n\n## Polygons\n\n::: justify\nPolygons are enclosed linestrings (first and last vertex are the same). You can create `POLYGON` geometries with `sf::st_polygon()` function. The function takes a list as an argument which contains one or more linestring matrices where the first and last rows are the same XY coordinate within a list element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npol_list <- matrix(c(10,10,10,20,20,20,20,10,10,10), ncol = 2, byrow = T) |> list()\npol <- sf::st_polygon(pol_list)\nattributes(pol)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$class\n[1] \"XY\"      \"POLYGON\" \"sfg\"    \n```\n:::\n:::\n\n\nYou can create more complex polygons by adding more polygon matrices to the list. For example, you can add a hole to the main polygon, by encompassing a smaller polygon.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npol_list[[2]] <- matrix(c(15,15,15,16,16,16,16,15,15,15), ncol = 2, byrow = T)\npol_with_hole <- sf::st_polygon(pol_list)\nplot(pol_with_hole, col = c(\"red3\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=100% height=250%}\n:::\n:::\n\n\nLike for points and lines, you can create an `sf` object with multyple polygons, attributes and a CRS.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntriangle <- matrix(c(1,1,3,4,5,1,1,1), ncol = 2, byrow = T) |> list() |> sf::st_polygon()\nsquare <- matrix(c(1,5,1,9,5,9,5,5,1,5), ncol = 2, byrow = T) |> list() |> sf::st_polygon()\npentagon <- matrix(c(8,3,7,5,9,7,11,5,10,3,8,3), ncol = 2, byrow = T) |> list() |> sf::st_polygon()\n\npol_sfc <- sf::st_sfc(triangle, square, pentagon, crs = 4326)\n\npol_att <- data.frame(type = c(\"triangle\", \"square\", \"pentagon\"))\n \npol_sf <- sf::st_sf(pol_att, pol_sfc)\npol_sf\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"type\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"pol_sfc\"],\"name\":[2],\"type\":[\"s_POLYGO\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"triangle\",\"2\":\"<s_POLYGO>\",\"_rn_\":\"1\"},{\"1\":\"square\",\"2\":\"<s_POLYGO>\",\"_rn_\":\"2\"},{\"1\":\"pentagon\",\"2\":\"<s_POLYGO>\",\"_rn_\":\"3\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nBelow the three polygons plotted with `ggplot2` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npolyplot <- ggplot2::ggplot(pol_sf, aes(geometry = pol_sfc, fill = type)) +\n  geom_sf(show.legend = F) +\n  geom_sf_text(aes(label = type)) +\n  labs(x = \"lon\", y = \"lat\", title = \"Some polygons on 4326 CRS\")\npolyplot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=100% height=250%}\n:::\n:::\n\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\r\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}